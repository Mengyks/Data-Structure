这里是二叉树的制作笔记1，里面包含了创建二叉树和遍历二叉树的内容。

创建二叉树:
  想要创建二叉树，就先要根据二叉树的特点创建对应的结构体。二叉树与链表类似，都有数据域和指针域，但是二叉树的指针域更加特殊，他有左指针和右指针，分别指向自己的左孩子和右孩子。那么我们根据这个特点定义他的结构体：
    struct BiNode{
        ElemType data;//数据域
        BiNode *lchild,*rchild;//指针域
    }BiNode,*BiTree;
![树结构示意图](https://github.com/Mengyks/Data-Structure/blob/main/BiTreeNote/BiTreePict/BiTree1.png)
  实际上有些时候我们需要一些辅助的参数来帮助我们对二叉树进行操作，因此在创建结构体的时候，我们可以加上一个flag标志变量，为以后的操作伏笔。
    struct BiNode{
        int flag;//标志变量
        ElemType data;//数据域
        BiNode *lchild,*rchild;//指针域
    }BiNode,*BiTree;
  但是不同于链表的输入形式，我们在输入二叉树的时候通常使用便于输入的先序拓展序列作为输入序列，这种序列一般是使用顺序存储的方式，但是我们实际操作的时候大多是用链式存储的操作，所以我们的创建要将一个先序拓展序列转换成链式存储的二叉树。那么问题来了，什么是先序拓展序列，他其实就是将一个正常的二叉树用先序遍历的方式遍历完，当遇到空指针时用某个字符替代(我这里一般是用'@'来替代)，这样我们就能得到一个对应的伪完全二叉树了，这种伪完全二叉树能较好的保留原来二叉树的信息，方便我们转换。

![先序拓展序列示意图](https://github.com/Mengyks/Data-Structure/blob/main/BiTreeNote/BiTreePict/BiTree2.png)

  我们一般有两种方式将先序拓展序列转换成链式二叉树，一种是递归，一种是栈。这两种方式中递归明显要更加简单，而且更加常用，但是我还是写了一个栈的版本，那个非常复杂，而且意义不大，这里只讲递归的版本。递归的思想总结一下就是你尽管写出口，计算机会自己帮你算，那么我们递归创建的第一个目标就是找到他的出口是哪儿。我们不妨设想一下，一个只有左子树的二叉树，通过递归一路向左到最后的结局是什么？那当然是左子树为空且右子树为空，那么我们能很自然的想到他的递归出口就是当节点为空。那么当节点为空时，我们要做什么,因为我们的节点是一路向左来的，那么败者食尘回到上一个节点的时候直接走右节点就行，这样我们就完成了递归创建二叉树的过程。具体代码可以看代码文件。

遍历二叉树：
  Congratulations!你已经完成了二叉树的建立，那么我们迫不及待的想看看我们创建的二叉树是怎么样的，那么我们要怎么遍历我们创建的二叉树呢？我们可以想到两种方式，第一种就是一个劲的走到头，直到走不了，开始回头走；另外一种则是我们把每一层走完，像贪吃蛇一样扫描完整个一层再到下一层。这两种方法都是可行的，前者可以说是深度优先，而后者则可以认为是广度优先，这里先介绍深度优先的方法，广度优先的方法后面同样会有介绍。对于第一种情况，我们分为三种遍历方式就是先序、中序和后序遍历，这三种遍历方式同样可以用递归和栈两种方法实现，同样，递归的方法明显简单与栈，但是这里栈的遍历也并没有栈创建那么难，所以会顺带介绍一下。递归的方法不同于栈，递归方法就像一条固定的管子，我们往里面加水他始终会沿着这条管子走，至于先序中序后序只不过是我们选择在管子的那个地方割断，让水能够喷出来而已。递归的代码非常简单：
    void order(BiTree T)
    {
        if(T==NULL) return;//递归的出口
        order(T->lchild);
        order(T->rchild);
    }
  就如同其他递归一样，我们要找到递归的出口，当我们一直往下走到最底时，我们一定会走到一个NULL域，此时就说明我遍历完了一条线，就可以退出这一层回溯。就如下图红色的线一样，他表示了我们遍历的轨迹，不管是那个顺序，他的轨迹都是这样的。想要达到先序中序后序遍历，只需要对上述代码稍微修改即可:
    void order(BiTree T)
    {
        if(T==NULL) return;//递归的出口
        //pirntf("%c",T->data)//先序
        order(T->lchild);
        //pintf("%c",T->data)//中序
        order(T->rchild);
        //printf("%c",T->data)//后序
    }
  //printf位置的不同，决定了不同的遍历方式。
![遍历示意图](https://github.com/Mengyks/Data-Structure/blob/main/BiTreeNote/BiTreePict/BiTree3.png)

  但是栈的遍历就要复杂一些，尤其是后序遍历，后序遍历要我们先遍历完左右节点才行，就像一个超级大慢刀，我们一旦提前翻滚就会被抓滚（bushi）。而对于中序和先序遍历则与上面的递归类似，只是printf的位置不同而已。这里给出代码：
    //先序
    void PreOrderByStack(BiTree T)
    {
        BiStack S;
        InitBiStack(S);
        if(T==NULL) return;
        BiTree p=T;//类似于链表，尽量不动根节点
        while(p!=NULL||!EmptyBiStack(S))
        {
            if(p!=NULL)
            {
                printf("%c",p->data);//进栈则直接输出
                PushBiStack(S,p);
                p=p->lchild;
            }
            else
            {
                p=PopBiStack(S);//发动败者食尘回溯
                p=p->rchild;
            }
        }
    }
    //中序
    void InOrderByStack(BiTree T)
    {
        BiStack S;
        InitBiStack(S);
        if(T==NULL) return;
        BiTree p=T;//类似于链表，尽量不动根节点
        while(p!=NULL||!EmptyBiStack(S))
        {
            if(p!=NULL)
            {
                PushBiStack(S,p);
                p=p->lchild;
            }
            else
            {
                p=PopBiStack(S);//发动败者食尘回溯
                printf("%c",p->data);//先等节点的左子树没了再输出，抓个滚
                p=p->rchild;
            }
        }
    }
  因为二叉树的遍历需要回溯，所以栈的作用就是存储之前的节点方便回溯，同时先进后出的方式也满足回溯的逻辑。
  最麻烦的是栈的后序遍历，因为后序遍历要遍历完左右子树才能输出节点。因此我们就需要利用一个标志变量来记录我们这个节点当前状态，比如说flag=0表示此节点完全没有遍历左右子树，flag=1表示此节点已经遍历完左子树，
  flag=2表示此节点已经遍历完左右子树。那我们让节点输出的时机，就是栈顶元素的flag=2的时候。根据这个原理，我们可以写出代码：
    //后序遍历
    void PostOrderByStack(BiTree T)
    {
        BiStack S;
        InitBiStack(S);
        if(T==NULL) return;
        BiTree p=T;
        p->flag=1;
        PushBiStack(S,p);
        p=p->lchild;//先填充一个进栈，不然用do-while也可以的
        while(!EmptyBiStack(S))//千万不要跟前面一样或上一个p!=NULL，后序遍历最后一个是根节点，他肯定不是空的，那你p回到根节点了不就死循环了吗
        {
            if(p!=NULL)
            {
                p->flag=1;//你已经不是纯良了
                PushBiStack(S,p);
                p=p->lchild;
            }
            else
            {
                while(!EmptyBiStack(S)&&GetTopBiStack(S)->flag==2)//通过栈顶元素判断是否已经遍历过两次了，不能用p，原理和上面用栈创建树差不多
                {
                    p=PopBiStack(S);
                    printf("%c",p->data);
                }
                if(!EmptyBiStack(S))
                {
                    p=GetTopBiStack(S);//不能弹，只能取，不然会出BUG，原因和上面栈创建树差不多
                    p->flag=2;
                    p=p->rchild;
                }
            }
        }
    }
  用栈来后序遍历需要注意的事项明显比前序和中序要多了，所以实际上更多的时候是用递归来完成遍历，即使递归不方便，也一般会使用中序和前序的栈来扫描二叉树。

结语：
  二叉树的创建和遍历主要还是以递归为主，但是我在网上见过一句话就是递归是计算机的思想，迭代是人的思想，所以我尝试不用递归去写（但是你也没用迭代啊喂，混蛋），发现复杂度明显高于递归，今天花了两个小时左右的时间去写栈创建二叉树的函数，但是其实本来不用那么久的，因为我前面的问题是因为我栈的函数没有加引用(我艹了啊)，然后我发给我老师问问她怎么去简化了去折磨他了（大雾），如果大伙可以的话，还是尽量用递归吧。如果有什么好的思路代码有问题也欢迎分享指正。最后来一段魂语：
    "二叉树的一些笔记内容，记载了有关二叉树的信息。"

    "能学会基本的二叉树创建和遍历。"

    "树的生根发芽永远不止于二分。"
    "大多数学者流派不屑于其简单的结构。"
    "而彼海姆龙学院的学者则认为大道至简。"
